# 프로세스 개념
우리가 운영체제를 논의 할 때, 한가지 장애는 모든 CPU활동들을 어떻게 부를 것인가 하는 의문이 존재한다.
일괄 처리 시스템은 잡(job)을 실행하는 반면에, 시분할 시스템은 사용자 프로그램 또는 테스크 (Task)들을 가진다.

> 일괄처리 시스템은 무엇인가? </br>
> 초기의 컴퓨터 시스템에서 사용된 형태로, 일정량 또는 일정 기간 동안 데이터를 모아서 한꺼번에 처리하는 방식 </br> 출처: https://lee-mandu.tistory.com/466 [개발/일상_Mr.lee]

> 시분할 시스템이란 무엇인가? </br>
> 시분할 시스템 </br>  → 여러 명의 사용자가 사용하는 시스템에서 컴퓨터가 사용자들의 프로그램을 번갈아가며 처리해 줌으로써 각 사용자에게 독립된 컴퓨터를 사용하는 느낌을 주는것으로, 라울드 로빈 방식이라고도 한다.</br>   - 여러 사용자가 각자의 단말장치를 통하여 동시에 운영체제와 대화하면서 각자의 프로그램 실행 </br> - 하나의 CPU는 같은 시점에서 여러 개의 작업을 동시에 수행할 수 없기 때문에 CPU의 전체 사용 시간을 작은 작업 시간량으로 나누어서 그 시간량 동안만 번갈아가면서 CPU를 할당하여 각 작업을 처리 </br> - 효율은 좋아지나 개인별 사용자 입장에서는 반응 속도가 느릴 수 있음 </br> 출처: https://lee-mandu.tistory.com/466 [개발/일상_Mr.lee]

우리는 이러한 것들을 전부 프로세스 라고 부른다.

### 프로세스
프로세스는 실행중인 프로그램을 말한다. 

프로세스가 포함하는 것들을 알아보자.
- 프로그램 카운터(PC)
- 처리기 레지스터
- 스택(STACK) (함수의 매개변수, 복귀주소, 로컬 변수 같은 임시적인 자료를 보관함)
- 데이터 영역
- 힙(HEAP)

프로그램 그 자체는 프로세스가 아니다.
프로그램은 명령어 리스트를 내용으로 가진 디스크에 저장된 파일과 같은 수동적 존재다.
이와는 다르게 프로세스는 실행할 명령어를 지정하는 프로그램 카운터와 관련 자원의 집합을 가진 능동적인 존재다.

실행 파일이 메모리에 적재될 떄 프로그램은 비로소 프로세스가 되는 것이다.

### 프로세스 상태(Process State)
- new : 프로세스가 생성
- running : 명령 실행
- waiting : 프로세스가 어떤 사건 일어나기를 대기
- ready : 프로세스 처리기에 할당되기를 대기
- terminated : 프로세스 실행 종료

### 프로세스 제어 블록(Process Control Block)
각 프로세스들은 운영체제에서는 프로세스 제어 블록(PCB)에 의해 표현된다.
여러가지 정보들을 포함하는데 대표적인 요소들을 알아보자.
- 프로세스 상태 : 상태는 new, ready, running, waiting, halted 등
- 프로그램 카운터 : 프로세스가 다음에 실행할 명령어의 주소
- CPU 레지스터 : 누산기(accumulator), 인덱스 레지스터, 스택 레지스터, 범용 레지스터, 상태 코드 정보들이 포함된다.
- CPU-스케줄링 정보 : 프로세스의 우선순위, 스케쥴 큐에 대한 포인터와 다른 스케줄 매개변수 포함
- 메모리 관리 정보 : 운영체제에 의해 사용되는 메모리 시스템에 따라 Base Register, Limit Register값, 운영체제가 사용하는 메모리 시스템에 따라 테이블 또는 세그먼트 테이블 정보를 포함한다.
- Accounting 정보 : CPU 사용시간, 시간 제한, 계정 번호, 잡 또는 프로세스 번호 포함
- 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록

### 프로세스 스케줄링(Process Scheduling)
다중 프로그래밍의 목적은 CPU 이용을 최대화 하기 위해 항상 어떤 프로세스가 실행 되도록 하는 것에 있다.
시분할의 목적은 각 프로그램이 실행 되는 동안 사용자가 상호작용할수 있도록 프로세스들 사이에서 CPU를 빈번하게 교체하는 것이다.
이 목적을 달성하기 위해서 프로세스 스케줄러는 CPU에서 실행 가능한 여러 프로세스들 중에서 하나의 프로세스를 선택한다.

### 스케줄링 큐(Scheduling Queue)
프로세스가 시스템에 들어오게 되면, 이것들은 job Queue에 놓여지게 된다.
Job Queue는 시스템 안의 모든 프로세스들로 구성이 된다.
주 메모리(RAM)에 존재하며, 준비 완료 상태에서 실행을 대기하는 프로세스들은(ready Queue)에 놓이게 된다.
이 큐는 일반적으로 연결 리스트로 지정된다.

프로세스가 CPU를 할당받으면, 어느정도 실행을 하고 결국에는 인터럽트 되거나, 입출력 요청이 완료되는 것 같은 특별안 Event의 발생을 기다리게 된다.

### 스케줄러(Scheduler)
프로세스는 일생동안 다양한 스케줄링 큐들 사이를 이주한다.
운영체제는 어떠한 방식으로든 스케줄링 목적을 위해 프로세스들을 큐에서 반드시 선택해야 한다.

일괄 처리 시스템에서는 즉시 실행될 수 있는 것보다 더 많은 프로세스들이 종종 제출된다.
이러한 프로세스들은 대용량 메모리에 저장되어 나중에 실행 될 때 까지그곳에 유지된다.
장기 스케줄러(Job Scheduler)는 이 풀에서 프로세스들을 선택하여 실행 하기 위해 메모리에 적재한다.
단시 크제룰러(CPU스케줄러)는 실행 준비가 완료 되어있는 프로세스들중에서 선택하여 이들중 하나에게 CPU를 할당한다.

### 문맥 교환(Context Switch)
일전에 배웠던것 처럼, 인터럽트는 운영체제가 CPU를 현재 작업에서 빼앗아 커널 루틴을 실핼할 수 있게 한다.
이러한 연산은 범용 시스템에서는 자주 발생한다.
인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에 문맥을 복구할수 있도록 현재 실행중인 프로세스의 현재 문맥을 저장할 필요가 있다.
묵맥의 정보는 PCB에 존재한다.
구성은 다음과 같다.
- CPU레지스터 값
- 프로세스 상태
- 메모리 정보
등을 포함한다.
일반적으로 커널 모드이건, 사용자 모드이건 CPU의 현재 상태를 저장하는 작업을 수행하고(state save)
나중에 연산을 재개하기 위해 상태 복구 작업을 수행한다(state restore)

CPU를 다른 프로세스로 교환 하려면 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 보구하는 작업이 필요하다.
이러한 작업을 문맥 교환이라고 한다.

문맥 교환이 일어나면, 커널은 피 교체 프로세스의 문맥을 PCB에 저장하고, 실행이 스케줄된 새로운 프로세스의 저장된 문맥을 복구한다.
문맥 교환이 진행될 동안 시스템은 아무런 유용한 일을 할수 없기에 문맥 교환하는 시간은 순수한 오버헤드에 해당한다.

교환 속도는 메모리의 속도, 반드시 복사 되어야 하는 레지스터의 수, 특수 명령어의 존재에 좌우 된다.
문맥 교환시간은 하드웨어의 지원에 따라 크게 좌우된다.

문맥 교환은 단순히 현행 레지스터 집합에 대한 포인터를 변경하는 것을 포함한다.
물론 레지스터 집합들 보다도 활성 프로세서들이 많다면 시스템은 전처럼 레지스터 자료를 메모리 또는 메모리에서 복사해야한다.
여기에 더해 운영체제가 복잡할수록 문맥 교환시 해야할 작업의 양이 많아질수 있다.

## 프로세스에 대한 연산(Operation on Processes)

### 프로세스 생성(Process Creation)
프로세스는 실행 되는 동안 여러개의 새로운 프로세스들을 생성할 수 있다.
이때 생성되는 프로세스와 기존의 프로세스들은 마치 부모 자식 관계와 비슷하여
기존 프로세스 - 부모 프로세스
새로운 프로세스 - 자식 프로세스
로 칭하게 된다.
물론 이렇게 생겨난 자식 프로세스 역시 새로운 자식 프로세스를 생성할수 있다.

이러한 프로세스들의 관계는 마치 트리와 같다고도 볼수 있겠다.

UNIX, Linux, Windows같은 대부분의 현대 운영체제들은 유일한 프로세스 식별자(pid)를 사용하여 프로세스를 구분하게 된다.
pid는 시스템의 각 프로세스에게 고유한 값을 가지도록 할당된다.
이 식별자를 통하여 커널이 유지하고 있는 프로세스의 다양한 속성에 접근하기 위한 색인(index)로 사용이 된다.

일반적으로 프로세스가 자식 프로세스를 생성할 때, 그 자식 프로세스는 자신의 임무를 달성하기 위해 어떤 자원이 필요하다(CPU, 시간, 메모리, 파일, 입출력 등)
자식 프로세스는 이 자원을 운영체제로부터 직접 얻을수도, 부모 프로세스가 가진 자원의 부분 집합만을 사용하도록 제한될 수도 있다.
부모 프로세스는 자원의 일부분만을 사용하도록 자식 프로세스가 쓸 수 있게 제한하며, 자식 프로세스들을 많이 생성해 시스템 과부하로 상태로 만드는 프로세스를 방지 할 수 있다.

물리적 논리적인 자원을 제공하는것 이외에 부모 프로세스는 자식 프로세스에게 초기화 데이터를 전달이 가능하다.

프로세스가 새로운 프로세스를 생성할 때, 두 프로세스를 실행 시키는데 두가지 가능한 방법이 존재한다.
1. 부모는 자식과 병행하게 실행을 계속한다.
2. 부모는 일부 또는 모든 자식이 실행을 종료할때 까지 기다린다.
새로운 프로세스들의 주소 공간적 측면에서 볼때 당므과 같은 두가지 가능성이 있다.
1. 자식 프로세스는 부모 프로세스의 복사본이다.(자식 프로세스는 부모와 똑같은 프로그램과 데이터를 가진다.)
2. 자식 프로세스가 자신에게 적재될 새로운 프로그램을 가지고 있다.

