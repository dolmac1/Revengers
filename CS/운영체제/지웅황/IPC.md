# 프로세스간 통신(InterProcess Communication)

운영체제 내에서 실행되는 병행적 프로세스들은 독립적이거나, 협력적인 프로세스들일 수 있다.
프로세스가 시스템에서 실행중인 다른 프로세스들에게 영향을 주거나, 받지 않는다면 이를 독립적 프로세스라고 말한다.

다른 프로세스와 데이터를 공유하지 않는 프로세스는 독립적이다.
프로세스가 시스템에서 실행중인 다른 프로세스들에게 영향을 주거나 받는다면 이는 협력적인 프로세스다.

이러한 협력을 허용하는 환경을 제공하는데는 몇가지 이유가 있다.

- 정보 공유 (Information Sharing) : 여러 사용자가 동일한 정보에 관심이 생길수 있으므로, 그러한 정보를 병행적으로 접근할 수 있는 환경을 제공해야한다.
- 계산 가속화(Computation SpeedUp) : 만일 특정 태스크(Task)를 빨리 실행하고자 한다면, 그것을 서브 태스크로 나누어, 이들 각각이 다른 서브태스트크 들과 병렬로 실행되게 해야 한다.(복수개의 코어를 가졌을 때)
- 모듈성(Modularity) : 시스템 기능을 별도의 프로세스들 또는 스레드들로 나누어, 모듈식 형태로 시스템을 구성하기를 원할 수 있다.
- 편의성(Convenience) : 개별 사용자들이 한 순간에 작업할 많은 태스크를 가질수도 있다. 예를 들면, 한 사용자가 편집, 음악 듣기 및 컴파일 작업등을 병렬로 할 수 있다.

협력적 프로세스들은 데이터와 정보를 교환할 수 있는 프로세스간 통신(Interprocesses Communication IPC) 기법을 필요로 한다.
프로세스간 통신에는 기본적으로 공유 메모리와 메세지 전달 두 가지 모델이 포함되어 있다.
공유 메모리 에서는 협력 프로세스들에 의해 공유되는 메모리의 영역이 구축된다.
프로세스들은 그 영역의 데이터를 읽고 쓰고 함으로서, 정보를 교환 할 수 있다.
메세지 전달 모델에서는 통신이 협력 프로세스들 사이에서 교환되는 메세지를 통해서 이루어지게 된다.

메세지 전달 모델은 충돌을 회피할 필요가 없으므로, 적은 양의 데이터를 교환하는 데에 매우 유용 할 수 있다.
또한, 분산 시스템에서 공유 메모리보다 구현하기 쉽다.(분산 공유 메모리를 제공하는 분산 시스템이 존재하기는 한다)
거기에 더해 메세지 전달 시스템은 통상 시스템 콜을 사용하여 구현되므로 커널 간섭이나 부가적 시간 소비 작업들이 필요하기에 공유 메모리 모델에 비해, 속도가 늦어진다.
공유 메모리 시스템에서는 공유 메모리 영역을 구축 할 때만 시스템 콜이 필요하다.
공유 메모리 영역이 구축되면 모든 접근은 일반적인 메모리 접근으로 취급되어 커널의 도움이 필요가 없게 된다.

많은 CPU 코어를 가진 시스템에서의 연구에 따르면 공유 메세지 전달이 공유 메모리보다 훨씬 더 나은 성능을 보여주는데,
이유가 무엇일까?
- 공유 메모리는 공유 데이터가 여러 캐시 사이에서 이주하기에 발생하는 캐시 일관성 문제로 인해서 성능 저하가 발생한다.
- 따라서 시스템 코어가 증가할수록 IPC는 메세지 전달이 더 빠르고 안정적인 시스템이라는 것을 유추해볼수 있다.

## 공유 메모리(Share Memory)
공유 메모리를 사용하는 프로세스간 통신에서는 통신하는 프로세스들이 공유 메모리 영역으 ㄹ구축해야한다.
통상적으로 공유 메모리 영역은, 공유 메모리 세그먼트를 생성하는 프로세스의 주소 공간에 위치한다.
이 공유 메모리 세그먼트를 이용해서 통신하고자 하는 다른 프로세스들은 이 세그먼트를 자신의 주소 공간에 추가해야만 한다.
일반적으로 운영체제는 한 프로세스가 다른 프로세스의 메모리를 접근하는것을 금지한다.(세마포어, 뮤텍스 등등..)
공유 메모리는 둘 이상의 프로세스가 이러한 조건을 제거하는것을 동의하는 것을 필요로 하게된다.
그런 이후에 두 가지 이상의 프로세스가 공유 메모리 영역에 데이터를 읽고 씀으로서 정보를 교환 할 수 있게 된다.

## 메세지 전달 시스템(Message-Passing System)
메세지 전달 방식은 동일한 주소공간을 공유하지 않고도 프로세스들이 통신을하고, 그들의 동작을 동기화 할 수 있도록 허용하는 기법을 제공한다.
통신는 프로세스들이 네트워크에 의해 연결된 다른 컴퓨터들에 존재할 수 있는 분산 환경에서 특히 유용하다.

한가지 예로 www에 사용되는 채팅 프로그램은 서로 메세지를 교환하여 통신할수 있도록 설계되어있는데, 메세지 전달 시스템은 최소한 두가지 연산을 제공한다.
> send(message) receive(message)
프로세스가 보내는 메세지는 고정 길이 일수도 있고, 가변 길이 일수도 있다.
고정 길이 메세지만 보낸다면 시스템 수준의 구현은 직선적이고, 프로그래밍 작업을 힘들게 한다.
반면 가변 길이 메세지는 보다 복잡한 수준의 구현을 필요로 하지만 프로그래밍 작업은 더욱 간단해 진다.

만약 프로세스 P와 Q가 통신을 원한다면 반드시 서로 메세지를 주고 받아야만 한다.
이들 사이에 통신 연결(communication Link)가 설정되어야 한다.
하나의 링크와 send()/receive() 연산을 논리적으로 구현하는 다수의 방법들은 다음과 같다.
- 직접, 또는 간접 통신
- 동기식 또는 비 동기식 통신
- 자동 또는 명시적 버퍼링

### Naming
통신을 원하는 프로세스들은 서로를 indicating할수 있어야 한다.
직접 통신 하에서 통신을 원하는 각 프로세스는 통신에서 수신자, 송신자의 이름을 명시해야 한다.
- send(P, Message) - 프로세스 P에게 메세지를 전송한다.
- receive(Q, Message) - 프로세스 Q에게 메세지를 수신한다.

이 기법에서 통신 연결은 다음과 같은 특성들을 가진다.
- 통신을 원하는 각 프로세스의 쌍들 사이에 연결이 자동적으로 구축된다. 프로세스들은 통신을 위해 상대방의 Identity만 알면 된다.
- 연결은 정확히 두 프로세스들 사이에만 연관된다.
- 통신하는 프로세스들의 각 쌍 사이에는 정확하게 하나의 연결이 존재해야만 한다.

이러한 기법은 주소 방식에서 대칭성을 보인다.
즉, 송신자와 수신자 프로세스가 모두 통신 하려면 상대방의 이름을 제시해야 한다.
이 기법의 변형으로 주소 지정 시에 비대칭을 사용할 수도 있다.
송신자만 수신자의 이름을 지명하며, 수신자는 송신자의 이름을 제시할 필요가 없다.
이 기법에서 send와 receive는 다음과 같이 정의 된다.
- send(P, Message) - Process를 P에 전송한다.
- receive(id, message) - 임의의 프로세스로부터 메세지를 수신하고, 변수 id는 통신을 발생시킨 프로세스의 이름으로 설정된다.
이들 기법 모두의 단점은 결과로 얻어지는 프로세스의 정의의 제한된 모듈성에 있다.
프로세스의 이름을 바꾸면 모든 다른 프로세스 정의를 검사할 필요가 있을 수 있다.
옛 이름들에 대한 모든 참조를 찾아서 새로운 이름으로 변경해야 할 것인데, 이러한 하드 코딩 기법은 이 상황에서 신원을 명시적으로 표시해야 한다.
간접 통신 에서는 메세지들을 메일박스 또는 포트로 송신되고 그것으로부터 수신된다.
메일 박스는 추상적으로, 프로세스들에 의해 메세지들이 넣어지고, 메세지들이 제거될 수도 있는 객체라고 볼수 있다.
각각의 메일 박스는 고유의 id를 가진다.
POSIX 메세지 큐는 메일 박스를 식별하기 위해 정수값을 사용한다. 이 기법에서 프로세스는 다수의 서로 다른 메일 박스를 통해 다른 프로세스들과 통신할 수 있다.

두프로세스들이 공유 메일 박스를 가질 때만 이들 프로세스가 통신할 수 있다.
- send(A, Message) - 메세지를 메일박스 A로 송신한다.
- receive(A, Message) - 메세지를 메일박스 A에서 수신한다.
이러한 통신 연결은 다음과 같은 특징을 가진다.

- 한쌍의 프로세스들 사이의 연결은 이들 프로세스가 공유 메일 박스를 가질 때만 구축된다.
- 연결은 두 개 이상의 프로세스들과 연관 될 수 있다.
- 통신하고 있는 각 프로세스들 사이에는 다수의 서로 다른 연결이 존재할 수 있고, 각 연결은 하나의 메일박스에 대응 된다.



