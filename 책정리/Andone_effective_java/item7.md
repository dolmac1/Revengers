# Item 7 다 쓴 객체 참조를 해제하라

Java 같은 경우는 Jvm에 의해서 GC 과정을 수행해준다.

일반적인 경우는 (요즘은 메모리의 크기가 커서) JVM의 GC가 잘 수행되지만 이러한 연산이 많이 늘어나게 되는 경우 GC 과정과 메모리 사용량이 늘어나게 되어 OOM을 발생시키며 프로그램이 종료된다.

### 직접 메모리를 관리하는 클래스

Stack 객체의 예를 보면

```java
public Object pop(){
  if(size == 0 )
    throw new EmptyStackException();
  return elements[--size];
}
```

이 경우에는 객체가 비활성화 되는 경우에도 객체 할당을 해제하지 않는다.

따라서 이 경우에는

```java
public Object pop(){
  if(size == 0 )
    throw new EmptyStackException();
  Object result = elements[--size];
  elements[size] = null //다 쓴 객체 참조 해제
  return result;
}
```

이렇게 객체를 해제해준다. 이를 통해 만약 null로 참조를 해제한 객체를 참조할경우 nullpointexception을 던져주게 된다.

다만 이렇게 null로 처리해 주는 경우는 예외적인 경우여야 하는데 자기 메모리를 직접 관리하는 경우에만 사용해야한다. 자기가 메모리를 직접 사용하는 경우는 프로그래머는 항상 메모리 누수에 주의를 해야한다. 원소를 다 사용한 즉시 객체를 null로 해제해줘야 한다.(위 예에 있는 Stack의 경우는 직접 pool을 만들어 요소를 관리한다.)



### 캐시

캐시 역시 메모리 누수를 일으키는 주범이다. 객체를 캐시에 넣어 놓고 잊은채 객체를 한참을 냅두는 경우가 있다.

우연히 얻은 key를 통해서 참조하는 동안에만 엔트리가 살아있는 캐시가 필요한 경우라면 WeakHashMap을 이용하여 사용한다. 다 쓴 엔트리는 그 즉시 제거된다. 하지만 캐시를 언제까지 사용할 지 모르기 때문에 엔트리를 시간이 지날수록 사용 중요도가 떨어지도록 관리를 하거나 엔트리를 한번씩 청소해줘야 한다.



### 리스너 혹은 콜백

리스너와 콜백은 클라이언트가 해지하지 않는한 콜백이 계속 쌓여간다. 이러한 것들을 약한 참조로 저장하면 가비지 컬렉터를 즉시 수거해 간다.

(이때 또한 WeakHashMap에 키로 저장하면 된다.)



