# item 19 상속을 고려해 설계하고 문서화하라. 그러지 않았다만 상속을 금지하라.

이전 아이템에서는 상속보다는 컴포지션을 고려하라고 하였다. 하지만 완벽하게 is-a 관계인 경우에는 그리고 프로그래머가 온전히 컨트롤 할 수 있는 경우에는 상속을 사용해도 좋다고 하였다. 이때 꼭 문서화를 철저히 해야한다. 

특히 __상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야한다.__

pubilc으로 공개된 함수(API)여서 외부에서 함수를 호출하는 경우인데 그것이 상속후 재정의가 된다면 문서에 반드시 작성을 잘 해놓아야 한다.

API 문서에서 "Implementaion Requirements"로 시작되는 절은 그 메서드의 내부 동작 방식을 설명하는 곳이다.



## 좋은 API 문서란?

좋은 API 문서는 "어떻게가 아니라 무엇을 하는지를 설명하는 것이 좋은 문서다." 라는 격언과는 위에서 설명한 내용이 반대된다. 하지만 캡슐화를 해치기 때문에 일어나는 어쩔 수 없는 방식이며 안전하게 상속 할 수 있도록 하기 위해서는 문서에 내부 구현 방식을 반드시 상세히 설명해놓아야 한다.

내부 매커니즘을 문서로 남기는 것만이 설계의 전부는 아니다. __클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드의 형태로 공개해야 할 수도 있다.__ 드물게는 protected 필드로 공개해야할 수도 있다.



## 상속용 클래스

상속용 클래스를 시험하는 방식은 직접 하위 클래스를 만들어 보는 수 밖에 없으며 만약 꼭 필요한 protected 맴버를 놓쳤다면 그 빈자리가 바로 보일것이다. 만약에 전혀 쓰이지 않는다면 private이어야 할 가능성이 높다.

그러므로 __상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.__

상속을 허용하는 클래스가 지켜야 하는 제약이 몇가지 더 있는데 __상속용클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다. __아래는 그 잘못된 예이다.

```java
public class Super {
  public Super() {
    overrideMe();
  }
  
  public void overrideMe() {
  }
}

public final class Sub exteds Super {
  private final Instant instant;
  
  Sub() {
    instant = Instant.now();
  }
  
  @Override public void overrideMe() {
    System.out.println(instant);
  }
  
  public static void main(String[] arg) {
    Sub sub = new Sub();
    sub.overrideMe();
  }
}
```

이 프로그램이 instant를 두 번 출력하리라 기대했겠지만, 첫번째는 Null을 출력하는데 생성자가 인스턴스 필드를 초기화 하기도 전에 overrideMe를 호출하기 떄문이다. 단, private, final, static 메서드는 재정의가 불가능 하기 때문에 안심하고 불러도 된다.



## Cloneable과 Serializable

Cloneable과 Serializable 인터페이스는 상속용 설계의 어려움을 더해준다. 둘 중 하나 구현한 클래스를 상속할 수 있도록 만드는 것은 좋은 생각이 아니다. 그 클래스를 확장하는 것은 프로그래머에게 매우 큰 부담이다. clone과 readObject는 생성자와 비슷한 효과를 내기때문에 __clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.__



## 결론

따라서 근본적으로 상속이 꼭 필요한것 아니라면 상속을 금지하는 것이 가장 좋으며 인터페이스를 정의하도록 하거나 래퍼 클래스 패턴을 이용하는 것이 좋다.