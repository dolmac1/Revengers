# Item3 private 생성자나 열거 타입으로 싱글턴임을 보증하라

싱글턴이란 인스턴스를 하나만 생성할 수 있는 클래스를 말한다. 전형적인 예로는 함수와 같은 무상태 객체나 설계상 유일해야하는 컴포넌트들이 있다.

__*하지만 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트가 테스트 하기가 어려워진다.*__

타입을 인터페이스로 정의한다음 그 인터페이스를 구현해서 만든 싱글턴이 아니라면 싱글턴은 Mock 객체로 만들 수 없기 때문이다.



## 싱글턴을 만드는 방법

1. private으로 생성자를 감춰두고 유일한 인스턴스에 접근할 수 있는 수단으로 public static을 이용해 메서드를 하나 남겨놓는다.

   pulbic static final을 통해서 인스턴스를 생성하고 생성자를 private으로 막아서 인스턴스를 추가로 생성할 수 없도록 한다.

2. 정적 팩터리 매서드를 public static 멤버로 제공한다. Class이름.getInstance() 함수를 이용해서 해당 인스턴스를 반환해준다.

1번의 장점은 해당 클래스가 싱글턴임이 API에 명백하게 드러난다는 것이다. 또한 간결하다.

2번의 장점은 API를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다. 두번째는 원한다면 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다는 것이다.(아이템30) 세번째 장점은 정적 팩터리의 메서드 참조를 공급자로 사용할 수 있다는 점이다. 가령 Elvis::getIntance를 Supplier<Elvis>로 사용하는 식이다. 이러한 장점들이 필요하지 않다면 public 방식이 더 좋다.

둘 중 하나의 방식으로 만든 싱글턴 클래스를 직렬화 하려면 단순히 Serializable을 구현한다고 해결되지 않는다.따라서 모든 모든 인스턴스 필드를 일시적이라고(transient) 선언하고 readResolve 메서드를 제공해야한다. 이렇게 안한다면 역직렬화 할 때마다 새로운 인스턴스가 만들어진다. 즉 가짜 객체가 생겨난다는 것이다. 따라서 readResolvce(return INSTNACE)를 구현한다.

3. 원소가 하나인 열거타입(Enum)을 선언한다. 대부분의 상황에서는 이 방식이 제일 좋지만 상속해야하는 상황에서는 쓸 수 없다. 하지만 이 방식은 추가 노력없이 직렬화 할 수 있으며 복잡한 상황에서의 직렬화 상황과 리플렉션 공격에서도 제2의 인스턴스가 생기는 일을 완벽하게 막아준다.

