# Item 8 finalizer와 cleaner 사용을 피하라

자바에는 두가지 소멸자가 존재한다.

1. Finalizer : 예츨할 수 없고 상황에 따라 위험할 수 있다. 오동작, 낮은 성능, 이식성 문제의 원인이 되기도 한다. (자바 9부터는 deprecated api로 지정되었다.)
2. cleaner : finalizer보다는 덜 위험하지만 여전히 느리고 예측할수 없기 때문에 불필요하다.

위 두가지 모두 C++에서의 파괴자와는 다른 개념이다. C++에서의 파괴자는 자원을 회수하는 일반적인 방법으로서 사용되지만 java에서는 GC가 알아서 자원 할당을 해제해주기 때문에 프로그래머가 추가적으로 신경써 줄 것이 없다.



### 문제점 1

finalizer와 cleaner는 실행이 되기 까지 얼마의 시간이 소요되는지 예측할 수 없기 때문에 제시간에 실행되어야 하는 작업에서는 절대로 사용해서는 안된다. __이 두 소멸자가 언제 수행되는지는 GC의 알고리즘에 따라 다르며 GC의 구현 방법마다 다르다.__ 따라서 실제 고객의 환경에서는 제대로 돌아가지 않을 가능성이 있는것이다.



### 문제점 2

finalizer는 스래드의 순서를 조정할 수 없기 때문에 전혀 예측 불가능 하지만 cleaner는 그나마 조절이 가능해 finalizer보다는 낫지만 앞서 여러번 이야기 했다시피 GC에 의해 컨트롤 되기 떄문에 수행된다는 보장이 없으며, 자바 명세 상 수행여부를 보장하지 않는다. 따라서 *__상태를 영구적으로 수정해야하는 작업에서는 사용해서는 안된다.__*



### 문제점 3

finalizer의 동작중 발생한 예외는 무시되며 처리되야할 작업이 남았어도 그 순간 종료된다. 처리를 해야하는 예외가 있는데 해당 예외를 무시하고 지나가는 경우가 있을 수 있다. 그리고 다른 스레드가 이렇게 훼손된 메모리를 건들게 된다면 어떠한 예외가 발생할지 프로그래머는 예측할 수 없다.



### 문제점 4

finalizer와 cleaner는 심각한 성능문제를 발생시킨다. AutoCloseable 객체를 생성하고 가비지 컬랙션까지의 시간이 12ns가 걸린 반면 finalizer를 사용하면 550ns가 걸려 50배 느린 성능을 보인다. 하지만 예외적으로 사용되는 상황에서는 조금 더 빠른 성능을 보이지만 여전히 66ns로 느리다.



### 문제점 5

finalizer를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수 있다. 생성자나 직렬화 과정에서 예외가 발생한다면 이 생성되다 만 객체에서 악위적인 하위 클래스의 finalizer가 수행될 수있다. 이 finalizer에 의해 정적 필드에 자신을 참조하여 GC를 일어나지 못하게 막을 수 있다. __객체 생성을 막는것을 생성자에서 예외를 던지는 것으로 충분히 대처할 수 있지만 finalizer가 존재한다면 보장할 수없다.



### 사용처

적절한 사용처에는 2가지가 있다. 

1. 자원의 소유자가 close 메서드를 호출하지 않는것에 대비하는 것인다 FileInputStream, FileOutputStream, ThreadPoolExecutor가 대표적이며 finalizer를 통해 안전망을 구축한다.
2. 네이티브 피어와 연결된 객체이다. 네이티브 피어란 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체를 말한다. 네이티브 피어는 자바 객체가 아니므로 자바 JVM이 그 존재를 알 수 없으며 이러한 객체 자원을 해제 처리 할때 사용될 수 있다. 하지만 성능 저하는 여전히 존재하므로 자원을 즉시 회수 해야 하는 경우는 반드시 close 메서드를 호출해줘야 한다.







